"""
Flux Open Home - Irrigation Management API
============================================
A Home Assistant add-on that supports two modes:
- Homeowner: Exposes a secure, scoped API for irrigation management
- Management: Dashboard to monitor and control multiple homeowner systems

Author: Brandon / Flux Open Home
"""

import asyncio
import json
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request, Response
from fastapi.responses import RedirectResponse
from fastapi.middleware.cors import CORSMiddleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

import os

from config import get_config, async_initialize
from audit_log import cleanup_old_logs
from routes import zones, sensors, schedule, history, system, admin, management


PROXY_SERVICE_NAMES = [
    "irrigation_proxy_get",
    "irrigation_proxy_post",
    "irrigation_proxy_put",
    "irrigation_proxy_delete",
]


async def _check_rest_command_service(config):
    """Check if rest_command.irrigation_proxy_* services are registered in HA."""
    import httpx
    try:
        token = config.supervisor_token
        if not token:
            print("[MAIN] Cannot check rest_command service — no supervisor token")
            return
        async with httpx.AsyncClient(timeout=10.0) as client:
            resp = await client.get(
                "http://supervisor/core/api/services",
                headers={"Authorization": f"Bearer {token}"},
            )
            if resp.status_code == 200:
                services = resp.json()
                rest_cmd = None
                for svc in services:
                    if svc.get("domain") == "rest_command":
                        rest_cmd = svc
                        break
                if rest_cmd:
                    svc_names = list(rest_cmd.get("services", {}).keys())
                    found = [s for s in PROXY_SERVICE_NAMES if s in svc_names]
                    missing = [s for s in PROXY_SERVICE_NAMES if s not in svc_names]
                    if not missing:
                        print(f"[MAIN] ✓ All irrigation_proxy rest_commands registered: {found}")
                    else:
                        print(f"[MAIN] ✗ Missing rest_commands: {missing}")
                        print(f"[MAIN]   Found: {found}")
                        print(f"[MAIN]   Available: {svc_names}")
                        # Check for old single-service name
                        if "irrigation_proxy" in svc_names:
                            print(f"[MAIN]   ⚠ Old 'irrigation_proxy' (single) found — needs HA restart with updated packages file")
                        print(f"[MAIN]   → Restart Home Assistant to pick up the updated packages file")
                else:
                    print(f"[MAIN] ✗ rest_command domain is NOT registered in HA!")
                    print(f"[MAIN]   → Check that configuration.yaml has:")
                    print(f"[MAIN]     homeassistant:")
                    print(f"[MAIN]       packages: !include_dir_named packages")
                    print(f"[MAIN]   → Then fully restart Home Assistant (not just reload)")
            else:
                print(f"[MAIN] Could not check services: HTTP {resp.status_code}")
    except Exception as e:
        print(f"[MAIN] Could not check rest_command service: {e}")


def _setup_rest_command_proxy():
    """
    Write a HA packages file that creates the rest_command.irrigation_proxy
    service. This allows management companies to reach this add-on through
    Nabu Casa via HA's REST API → rest_command → localhost:8099.
    """
    packages_dir = "/config/packages"
    package_file = os.path.join(packages_dir, "flux_irrigation_proxy.yaml")

    PACKAGE_CONTENT = """# Auto-generated by Flux Irrigation Management API add-on
# This enables Nabu Casa connectivity for management companies
# DO NOT EDIT — this file is regenerated on add-on startup
#
# NOTE: rest_command does NOT support Jinja templates in the 'method' field,
# so we create one entry per HTTP method. The management client calls the
# appropriate service (e.g. rest_command.irrigation_proxy_get).

rest_command:
  irrigation_proxy_get:
    url: "http://localhost:8099/{{ path }}"
    method: get
    headers:
      Content-Type: "application/json"
      X-API-Key: "{{ api_key }}"
    content_type: "application/json"

  irrigation_proxy_post:
    url: "http://localhost:8099/{{ path }}"
    method: post
    headers:
      Content-Type: "application/json"
      X-API-Key: "{{ api_key }}"
    payload: '{{ payload | default("{}") }}'
    content_type: "application/json"

  irrigation_proxy_put:
    url: "http://localhost:8099/{{ path }}"
    method: put
    headers:
      Content-Type: "application/json"
      X-API-Key: "{{ api_key }}"
    payload: '{{ payload | default("{}") }}'
    content_type: "application/json"

  irrigation_proxy_delete:
    url: "http://localhost:8099/{{ path }}"
    method: delete
    headers:
      Content-Type: "application/json"
      X-API-Key: "{{ api_key }}"
    content_type: "application/json"
"""

    try:
        # Log filesystem state for debugging
        print(f"[MAIN] Checking /config directory...")
        if os.path.exists("/config"):
            print(f"[MAIN]   /config exists (is_dir={os.path.isdir('/config')})")
            try:
                config_contents = os.listdir("/config")
                print(f"[MAIN]   /config contains {len(config_contents)} items")
                if "packages" in config_contents:
                    print(f"[MAIN]   /config/packages already exists")
                else:
                    print(f"[MAIN]   /config/packages does NOT exist — will create it")
            except Exception as e:
                print(f"[MAIN]   Cannot list /config: {e}")
        else:
            print(f"[MAIN]   WARNING: /config does NOT exist!")

        os.makedirs(packages_dir, exist_ok=True)
        print(f"[MAIN]   Created/verified {packages_dir}")

        # Check if file already exists with same content
        if os.path.exists(package_file):
            try:
                with open(package_file, "r") as f:
                    existing = f.read()
                if existing.strip() == PACKAGE_CONTENT.strip():
                    print("[MAIN] rest_command.irrigation_proxy package already configured")
                    return
            except Exception:
                pass  # Re-write the file

        with open(package_file, "w") as f:
            f.write(PACKAGE_CONTENT)

        # Verify it was written
        if os.path.exists(package_file):
            size = os.path.getsize(package_file)
            print(f"[MAIN] ✓ Created rest_command package at {package_file} ({size} bytes)")
        else:
            print(f"[MAIN] ✗ File write appeared to succeed but file not found!")

        print("[MAIN] IMPORTANT: Restart Home Assistant for the rest_command to take effect.")
    except PermissionError as e:
        print(f"[MAIN] ✗ PERMISSION ERROR writing to {packages_dir}: {e}")
        print("[MAIN]   The add-on needs 'config:rw' in config.yaml map section.")
        print("[MAIN]   Nabu Casa mode will not work until this is resolved.")
    except Exception as e:
        print(f"[MAIN] ✗ FAILED to write rest_command package: {type(e).__name__}: {e}")


# --- Rate Limiter ---
limiter = Limiter(key_func=get_remote_address)


# --- Periodic Tasks ---
async def _periodic_log_cleanup():
    """Run audit log cleanup once per day."""
    while True:
        try:
            cleanup_old_logs()
        except Exception as e:
            print(f"[MAIN] Log cleanup error: {e}")
        await asyncio.sleep(86400)  # 24 hours


async def _periodic_customer_health_check():
    """Periodically check connectivity to all customers (management mode only)."""
    while True:
        try:
            config = get_config()
            if config.mode == "management":
                from customer_store import load_customers, update_customer_status
                from management_client import check_homeowner_connection
                from connection_key import ConnectionKeyData

                customers = load_customers()
                for customer in customers:
                    try:
                        conn = ConnectionKeyData(
                            url=customer.url,
                            key=customer.api_key,
                            ha_token=customer.ha_token or None,
                            mode=customer.connection_mode or "direct",
                        )
                        result = await check_homeowner_connection(conn)
                        update_customer_status(customer.id, result)
                    except Exception as e:
                        print(f"[MAIN] Health check failed for {customer.name}: {e}")
        except Exception as e:
            print(f"[MAIN] Customer health check error: {e}")
        await asyncio.sleep(300)  # Every 5 minutes


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown lifecycle."""
    config = await async_initialize()
    print(f"[MAIN] Flux Irrigation API starting in {config.mode.upper()} mode...")

    # Always set up the rest_command proxy file — needed for Nabu Casa
    # connectivity regardless of current mode (user may switch modes later)
    _setup_rest_command_proxy()
    await _check_rest_command_service(config)

    if config.mode == "homeowner":
        print(f"[MAIN] Configured API keys: {len(config.api_keys)}")
        print(f"[MAIN] Irrigation device: {config.irrigation_device_id or '(not configured)'}")
        print(f"[MAIN] Resolved zones: {len(config.allowed_zone_entities)}")
        print(f"[MAIN] Resolved sensors: {len(config.allowed_sensor_entities)}")
        print(f"[MAIN] Rate limit: {config.rate_limit_per_minute}/min")
        print(f"[MAIN] Audit logging: {'enabled' if config.enable_audit_log else 'disabled'}")
        if config.homeowner_url:
            print(f"[MAIN] External URL: {config.homeowner_url}")
    else:
        from customer_store import load_customers
        customers = load_customers()
        print(f"[MAIN] Management mode: {len(customers)} customer(s) configured")

    # Start background tasks
    cleanup_task = asyncio.create_task(_periodic_log_cleanup())
    health_task = None
    if config.mode == "management":
        health_task = asyncio.create_task(_periodic_customer_health_check())

    yield

    # Shutdown
    cleanup_task.cancel()
    if health_task:
        health_task.cancel()
    print("[MAIN] Flux Irrigation API shutting down.")


# --- FastAPI App ---
app = FastAPI(
    title="Flux Irrigation Management API",
    description=(
        "Dual-mode irrigation management for Flux Open Home. "
        "Homeowners expose a secure API; management companies monitor "
        "and control multiple properties from a single dashboard."
    ),
    version="1.0.0",
    lifespan=lifespan,
    docs_url="/api/docs",
    redoc_url="/api/redoc",
    openapi_url="/api/openapi.json",
)

# --- Middleware ---
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Tighten this in production
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)


@app.middleware("http")
async def mode_guard_middleware(request: Request, call_next):
    """In management mode, the homeowner API routes still work so that:
    1. Remote management companies can reach this homeowner's API
    2. Same-instance management testing works (loopback)
    The homeowner API routes are protected by API key auth, so they're safe.
    Only the admin UI (GET /admin) switches between homeowner and management views.
    """
    response = await call_next(request)
    return response


# --- Routes ---
app.include_router(zones.router, prefix="/api")
app.include_router(sensors.router, prefix="/api")
app.include_router(schedule.router, prefix="/api")
app.include_router(history.router, prefix="/api")
app.include_router(system.router, prefix="/api")
app.include_router(admin.router)
app.include_router(management.router)


@app.get("/", include_in_schema=False)
async def root(request: Request):
    """Redirect root to admin UI, preserving ingress path prefix."""
    # Use a relative redirect so HA ingress path is preserved
    return RedirectResponse(url="admin", status_code=302)


@app.get("/api", include_in_schema=False)
async def api_root():
    return {
        "endpoints": {
            "zones": "/api/zones",
            "sensors": "/api/sensors",
            "schedule": "/api/schedule",
            "history": "/api/history/runs",
            "audit_log": "/api/history/audit",
            "system_status": "/api/system/status",
            "health": "/api/system/health",
            "docs": "/api/docs",
        }
    }
